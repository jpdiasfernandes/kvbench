from __future__ import (absolute_import, annotations, division, print_function)

__metaclass__ = type

DOCUMENTATION = r'''
---
module: deltas_summary_merger

short_description: Joins each delta information to a json summary

version_added: "1.0.0"

description: The results directory is organized by area of test.
Each area of test, in turn, is organized by tests timestamp.
Each test is comprised of various deltas, with one or more repetitions.
Each repetition contains summary information. This summary information
contains top level metrics: total energy consumption, total number of ops
performed, total duration, total number of compactions, average power...
On top of the metrics generated by default on each repetition, we can also add
more metrics, including memory metrics.

options:
    test_dir:
        description: A timestamped directory organized by delta tests
        required: true
        type: str
    area_name:
        description: The area name
        required: true
        type: str
    memory_metrics:
        descriptions: Flag to add or not add memory metrics in the summary info
        required: false
        type: bool
    chdir:
        description: A path to the current working directory
        required: false
        type: str
    output_prefix:
        description: A path to the output prefix prepended to all figures paths
        required: false
        type: str

author:
    - Jos√© Pedro Fernandes (@jpdiasfernandes)
'''

EXAMPLES = r'''
- name: Merge all the repetitions summary info to a json structure
  deltas_summart_merger:
      test_dir: /home/user/test_results/area_test/2024-12-04T09:56:37Z
      area_name: area
      memory_metrics: True
      ouput_prefix: /home/user/summary_results/memory_summary
'''

RETURN = r'''
'''

from ansible.module_utils.basic import AnsibleModule
import os
import json
import re
from packaging.version import Version

def check_version(option_file_name):
    basename = os.path.basename(option_file_name)
    if basename != "options.log":
        return Version('0.0.0')

    option_fd = open(option_file_name, "r")
    first_line = option_fd.readline()
    match = re.search(r'VERSION: ', first_line)
    if match != None:
        splited_line = first_line.split(' ')
        version = splited_line[-1]
        return Version(version)

    return Version('0.1.0')

def get_file_with_pattern(dir_path, re_pattern):
    res = []
    for relative_path in os.listdir(dir_path):
        if not os.path.isfile(dir_path + "/" + relative_path):
            continue
        match = re.search(re_pattern, relative_path)
        if match:
            res.append(os.path.abspath(dir_path + "/" + relative_path))
    return res

def get_options_file(dir_path):
    re_pattern = r'options(.*?)\.log'
    files = get_file_with_pattern(dir_path, re_pattern)
    if len(files) == 1:
        return files[0]
    return None

def get_sys_file(dir_path):
    return dir_path + "/sys-energy.csv"

def get_memory_consumption(test):
    sys_energy_fd = open(test, "r")
    total_memory = 0
    sys_total_consumption = 0
    for line in sys_energy_fd.readlines()[1:]:
        line_splited = line.split(";")
        total_memory += float(line_splited[4])
        sys_total_consumption += float(line_splited[2])

    return total_memory, sys_total_consumption

def get_test_name(dir_path):
    split_dir = os.path.abspath(dir_path).split('/')
    return split_dir[-2]

def get_test_date(dir_path):
    split_dir = os.path.abspath(dir_path).split('/')
    return split_dir[-3]
def get_test_area(dir_path):
    split_dir = os.path.abspath(dir_path).split('/')
    return split_dir[-4]

def get_repetitions(dir_path):
    #Repetitions are structured as repetition-rep_num dirs
    root = os.path.dirname(dir_path)
    reps = 0
    for path in os.listdir(root):
        if os.path.isdir(path) and re.search(r'repetition-\d+', os.path.basename(path)) != None:
            reps += 1
    return reps

def main(test_dir, area_name, memory_metrics, output_prefix, module, result):
    exclude_dir = [ ".git"]
    merged = {}
    visited_paths = set()

    for root, dirs, files in os.walk(test_dir):
        dirs[:] = [d for d in dirs if d not in exclude_dir]
        #just to make sure tests are sorted by ascending repetition order
        #changes traverse order that os walk will do
        dirs.sort()
        abs_summary_path = os.path.abspath(root) + '/summary_info.json'
        if "summary_info.json" in files and abs_summary_path not in visited_paths:
            visited_paths.add(abs_summary_path)
            summary_fd = open(abs_summary_path, "r")
            option_file = get_options_file(root)
            if option_file == None:
                module.fail_json(msg='Option log does not have a valid name format, please fix results structure')
            version = check_version(option_file)
            if version == Version('0.0.0'):
                module.fail_json(msg='Update version to compatible version with update results fs helper')

            test_name = get_test_name(root)
            test_date = get_test_date(root)
            test_area = area_name

            json_summary = json.load(summary_fd)
            if test_area not in merged:
                merged[test_area] = {}

            if test_name not in merged[test_area]:
                merged[test_area][test_name] = {}

            if memory_metrics:
                sys_energy_file = get_sys_file(root)
                sys_memory_consumed, sys_cpu_consumption = get_memory_consumption(sys_energy_file)
                json_summary["tests"][0]["energy_memory"] = sys_memory_consumed
                json_summary["tests"][0]["energy_cpu_and_mem"] = sys_memory_consumed + json_summary["tests"][0]["energy_consumed"]
                json_summary["tests"][0]["sys_cpu_energy"] = sys_cpu_consumption

            if test_date not in merged[test_area][test_name]:
                merged[test_area][test_name][test_date] = { "tests" : [] }
            merged[test_area][test_name][test_date]["tests"].append(json_summary["tests"][0])

    cur_dir = os.getcwd()
    file_name = output_prefix + ".json"
    abs_file_path = os.path.abspath(cur_dir + "/" + file_name)
    if not module.check_mode:
        merged_summary_fp = open(file_name, "w")
        json.dump(merged, merged_summary_fp)
        result['changed'] = True
        result['changes'].append({'action': 'write', 'path': abs_file_path})
    else:
        module.exit_json(msg=f'Would create summary merged json structure at {abs_file_path} relative to chdir')

def run_module():
    module_args = dict(
        test_dir=dict(type='str', required=True),
        area_name=dict(type='str', required=True),
        memory_metrics=dict(type='bool', default=False),
        chdir=dict(type='str', required=False),
        output_prefix=dict(type='str', default='summary')
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    result = dict(
        changed=False,
        changes = []
    )
    if module.params['chdir'] != None:
        os.chdir(module.params['chdir'])

    test_dir = module.params['test_dir']
    area_name = module.params['area_name']
    memory_metrics = module.params['memory_metrics']
    output_prefix = module.params['output_prefix']
    main(test_dir, area_name, memory_metrics, output_prefix, module, result)

    module.exit_json(**result)

if __name__ == '__main__':
    run_module()
